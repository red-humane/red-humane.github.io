<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Talk To Me - Global Chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000;
      color: #fff;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      padding: 16px 20px;
      background: #111;
      border-bottom: 1px solid #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header-title {
      font-size: 18px;
      font-weight: 600;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #888;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      transition: all 0.3s;
    }

    .status-dot.connected {
      background: #4CAF50;
      box-shadow: 0 0 8px #4CAF50;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      padding-bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
    }

    #messages::-webkit-scrollbar {
      width: 6px;
    }

    #messages::-webkit-scrollbar-track {
      background: transparent;
    }

    #messages::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 3px;
    }

    #messages::-webkit-scrollbar-thumb:hover {
      background: #444;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }

    .empty-state h2 {
      font-size: 20px;
      margin-bottom: 8px;
      font-weight: 500;
      color: #888;
    }

    .empty-state p {
      font-size: 14px;
      color: #555;
    }

    .setup-notice {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 20px;
      margin: 20px;
      color: #e53935;
    }

    .setup-notice h3 {
      margin-bottom: 10px;
      font-size: 16px;
    }

    .setup-notice p {
      font-size: 13px;
      line-height: 1.6;
      color: #ccc;
      margin-bottom: 8px;
    }

    .setup-notice code {
      background: #000;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      color: #4CAF50;
    }

    .message {
      max-width: 75%;
      padding: 12px 16px;
      border-radius: 18px;
      word-wrap: break-word;
      animation: slideIn 0.3s ease;
      font-size: 15px;
      line-height: 1.4;
      position: relative;
      transition: all 0.2s ease;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .message:active {
      transform: scale(0.98);
    }

    .message.selected-for-reply {
      box-shadow: 0 0 0 2px #4CAF50;
      transform: scale(0.98);
    }

    .message.fading {
      opacity: 0.5;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.received {
      align-self: flex-start;
      background: #1a1a1a;
      border-bottom-left-radius: 4px;
    }

    .message.sent {
      align-self: flex-end;
      background: #1d1d1d;
      border-bottom-right-radius: 4px;
    }

    .message-header {
      display: none;
    }

    .message-user {
      display: none;
    }

    .message-text {
      /* Only message text visible */
    }

    .message-time {
      display: none;
    }

    .message-expiry {
      display: none;
    }

    .reply-indicator {
      font-size: 11px;
      color: #888;
      border-left: 2px solid #555;
      padding-left: 8px;
      margin-bottom: 6px;
      font-style: italic;
    }

    #replyPreview {
      position: fixed;
      bottom: 70px;
      left: 20px;
      right: 20px;
      background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
      border: 2px solid #4CAF50;
      border-radius: 16px;
      padding: 14px 16px;
      display: none;
      animation: slideUp 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 999999;
      box-shadow: 0 4px 20px rgba(76, 175, 80, 0.5), 0 0 0 1px rgba(76, 175, 80, 0.3);
      pointer-events: auto;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s, visibility 0.2s;
    }

    #replyPreview.visible {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .reply-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .reply-preview-label {
      font-size: 11px;
      color: #4CAF50;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .reply-preview-label::before {
      content: "â†©";
      font-size: 14px;
    }

    .reply-cancel-btn {
      background: rgba(229, 57, 53, 0.15);
      border: none;
      color: #e53935;
      font-size: 16px;
      cursor: pointer;
      padding: 4px;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
      font-weight: bold;
    }

    .reply-cancel-btn:hover {
      background: rgba(229, 57, 53, 0.3);
      transform: scale(1.1);
    }

    .reply-cancel-btn:active {
      transform: scale(0.95);
    }

    .reply-preview-text {
      font-size: 14px;
      color: #ddd;
      line-height: 1.4;
      border-left: 3px solid #4CAF50;
      padding-left: 10px;
      max-height: 60px;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .input-area {
      padding: 16px 20px;
      background: #000;
    }

    .input-container {
      height: 48px;
      border-radius: 24px;
      background: #111;
      border: 1px solid #222;
      display: flex;
      flex-direction: row;
      align-items: center;
      transition: all 0.2s;
    }

    .input-container:focus-within {
      border-color: #333;
    }

    #messageInput {
      flex: 1;
      background: none;
      border: none;
      color: #fff;
      font-size: 16px;
      outline: none;
      padding: 0 16px;
    }

    #messageInput::placeholder {
      color: #666;
    }

    .send-button {
      padding: 0 12px;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      border: none;
      background: none;
    }

    .send-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #555;
      transition: background 0.2s;
    }

    .send-dot.active {
      background: #e53935;
    }

    .send-button:disabled {
      cursor: not-allowed;
    }

    @media (max-width: 768px) {
      .message {
        max-width: 85%;
      }

      .header-title {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-title">Talk To Me</div>
      <div class="status">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Connecting...</span>
      </div>
    </div>

    <div id="messages">
      <div class="empty-state" id="emptyState">
        <h2>Talk to me</h2>
        <p><strong>Disclaimer: </strong> Never share your personal details with strangers.</p>
      </div>
      <div class="setup-notice" id="setupNotice">
      </div>
    </div>

    <!-- Reply Preview - Fixed position, outside messages container -->
    <div id="replyPreview">
      <div class="reply-preview-header">
        <span class="reply-preview-label">Replying to message</span>
        <button class="reply-cancel-btn" id="cancelReplyBtn" title="Cancel reply">Ã—</button>
      </div>
      <div class="reply-preview-text" id="replyPreviewText"></div>
    </div>

    <div class="input-area">
      <div class="input-container">
        <input 
          type="text" 
          id="messageInput" 
          placeholder="Message..." 
          autocomplete="off"
          maxlength="500"
        >
        <button id="sendBtn" class="send-button" disabled>
          <div class="send-dot" id="sendDot"></div>
        </button>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { 
      getDatabase,
      ref,
      push,
      remove,
      onChildAdded,
      onChildRemoved,
      query,
      orderByChild,
      limitToLast
    } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';


    // ============================================
    // ðŸ”¥ FIREBASE CONFIG - REPLACE WITH YOUR OWN
    // ============================================
    const firebaseConfig = {
      apiKey: "AIzaSyCMtsjJCtHGZpYbt2IM4meuiqy5kL-axdo",
      authDomain: "talk-to-me-e3422.firebaseapp.com",
      databaseURL: "https://talk-to-me-e3422-default-rtdb.firebaseio.com",
      projectId: "talk-to-me-e3422",
      storageBucket: "talk-to-me-e3422.firebasestorage.app",
      messagingSenderId: "584227885310",
      appId: "1:584227885310:web:0003e3fd1f2f12ae48d5af",
      measurementId: "G-W45MRMR923"
    };

    // Check if Firebase is configured
    const isConfigured = !firebaseConfig.apiKey.includes('YOUR_');

    // State
    const state = {
      messages: new Map(),
      userId: generateUserId(),
      isConnected: false,
      expiryTimers: new Map()
    };

    // Elements
    const elements = {
      messages: document.getElementById('messages'),
      emptyState: document.getElementById('emptyState'),
      setupNotice: document.getElementById('setupNotice'),
      statusDot: document.getElementById('statusDot'),
      statusText: document.getElementById('statusText'),
      messageInput: document.getElementById('messageInput'),
      sendBtn: document.getElementById('sendBtn'),
      sendDot: document.getElementById('sendDot')
    };

    // Constants
    const MESSAGE_EXPIRY_TIME = 3 * 60 * 1000; // 3 minutes in milliseconds
    let lastSendTime = 0;     // spam throttle
    let cooldownTimer = null; // prevents multiple timers
    let replyingTo = null;    // stores reply target (hidden from UI)

    // Generate unique user ID
    function generateUserId() {
      const STORAGE_KEY = "talktome_uid";

      let savedId = localStorage.getItem(STORAGE_KEY);

      if (!savedId) {
        savedId = `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem(STORAGE_KEY, savedId);
      }

      return savedId;
    }

    // Format timestamp
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Calculate time remaining
    function getTimeRemaining(createdAt) {
      const now = Date.now();
      const elapsed = now - createdAt;
      const remaining = MESSAGE_EXPIRY_TIME - elapsed;
      
      if (remaining <= 0) return 'Expiring...';
      
      const minutes = Math.floor(remaining / 60000);
      const seconds = Math.floor((remaining % 60000) / 1000);
      
      if (minutes > 0) {
        return `${minutes}m ${seconds}s left`;
      }
      return `${seconds}s left`;
    }

    // Update connection status
    function updateConnectionStatus(connected) {
      state.isConnected = connected;
      elements.statusDot.classList.toggle('connected', connected);
      elements.statusText.textContent = connected ? 'Online' : 'Connecting...';
      elements.sendBtn.disabled = !connected || elements.messageInput.value.trim().length === 0;
      
      if (connected && isConfigured) {
        elements.setupNotice.style.display = 'none';
      }
    }

    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Add message to state
    function addMessage(messageId, data) {
      if (!data || !data.text || !data.userId || !data.timestamp) return;
      
      // Check if message already exists
      if (state.messages.has(messageId)) return;

      const messageData = {
        id: messageId,
        text: data.text,
        userId: data.userId,
        timestamp: data.timestamp,
        replyTo: data.replyTo || null,
        isMine: data.userId === state.userId
      };

      state.messages.set(messageId, messageData);
      
      // Setup expiry timer for UI update
      setupExpiryTimer(messageId, data.timestamp);
      
      renderMessages();
    }

    // Reply selector function - Shows LOCAL preview (not synced to Firebase)
    window.selectReply = function(messageId) {
      console.log('ðŸ”µ selectReply called for:', messageId);
      
      const msg = state.messages.get(messageId);
      if (!msg) {
        console.error('âŒ Message not found:', messageId);
        return;
      }

      // Remove previous selection highlight
      const prevSelected = document.querySelector('.selected-for-reply');
      if (prevSelected) {
        prevSelected.classList.remove('selected-for-reply');
      }

      // Store reply target (LOCAL - only for this user)
      replyingTo = msg;

      // Highlight the selected message
      const msgElement = document.querySelector(`[data-message-id="${messageId}"]`);
      if (msgElement) {
        msgElement.classList.add('selected-for-reply');
        console.log('âœ… Message highlighted');
      }

      // Show preview with full message
      const previewEl = document.getElementById('replyPreview');
      const textEl = document.getElementById('replyPreviewText');
      
      if (!previewEl || !textEl) {
        console.error('âŒ Preview elements not found!');
        console.log('previewEl:', previewEl);
        console.log('textEl:', textEl);
        return;
      }
      
      textEl.textContent = msg.text;
      previewEl.classList.add('visible');
      
      // Force visibility with multiple methods
      previewEl.style.display = 'block';
      previewEl.style.visibility = 'visible';
      previewEl.style.opacity = '1';
      previewEl.style.zIndex = '999999';

      console.log('âœ… Reply preview should be visible');
      console.log('Preview element display:', window.getComputedStyle(previewEl).display);
      console.log('Preview element visibility:', window.getComputedStyle(previewEl).visibility);
      console.log('Preview element opacity:', window.getComputedStyle(previewEl).opacity);
      console.log('Preview element position:', window.getComputedStyle(previewEl).position);
      console.log('Preview element bottom:', window.getComputedStyle(previewEl).bottom);
      
      // Notify React Native WebView
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'replySelected',
          text: msg.text.slice(0, 50),
          debug: {
            display: window.getComputedStyle(previewEl).display,
            visibility: window.getComputedStyle(previewEl).visibility,
            opacity: window.getComputedStyle(previewEl).opacity
          }
        }));
      }
    };

    // Setup expiry countdown timer
    function setupExpiryTimer(messageId, createdAt) {
      // Clear existing timer
      if (state.expiryTimers.has(messageId)) {
        clearInterval(state.expiryTimers.get(messageId));
      }

      // Update countdown every second
      const timer = setInterval(() => {
        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (!messageElement) {
          clearInterval(timer);
          state.expiryTimers.delete(messageId);
          return;
        }

        const expiryElement = messageElement.querySelector('.message-expiry');
        if (expiryElement) {
          const remaining = MESSAGE_EXPIRY_TIME - (Date.now() - createdAt);
          
          if (remaining <= 30000) { // Last 30 seconds
            messageElement.classList.add('fading');
          }
          
          if (remaining <= 0) {
            clearInterval(timer);
            state.expiryTimers.delete(messageId);
          } else {
            expiryElement.textContent = getTimeRemaining(createdAt);
          }
        }
      }, 1000);

      state.expiryTimers.set(messageId, timer);
    }

    // Remove message from state
    function removeMessage(messageId) {
      state.messages.delete(messageId);
      
      // Clear timer
      if (state.expiryTimers.has(messageId)) {
        clearInterval(state.expiryTimers.get(messageId));
        state.expiryTimers.delete(messageId);
      }
      
      renderMessages();
    }

    // Render all messages
    function renderMessages() {
      // Convert to array and sort by timestamp (ASCENDING ORDER - oldest first)
      const messagesArray = Array.from(state.messages.values())
        .sort((a, b) => a.timestamp - b.timestamp);

      if (messagesArray.length === 0) {
        elements.emptyState.style.display = 'block';
        return;
      }

      elements.emptyState.style.display = 'none';

      const html = messagesArray.map(msg => {
        const safeText = escapeHtml(msg.text);
        const isExpiringSoon = (MESSAGE_EXPIRY_TIME - (Date.now() - msg.timestamp)) <= 30000;
        
        return `
          <div class="message ${msg.isMine ? 'sent' : 'received'} ${isExpiringSoon ? 'fading' : ''}" 
               data-message-id="${msg.id}"
               style="transition: all 0.15s ease;">
            ${msg.replyTo ? `
              <div class="reply-indicator">
                ${escapeHtml(msg.replyTo.text)}
              </div>
            ` : ''}
            <div class="message-text">${safeText}</div>
          </div>
        `;
      }).join('');

      elements.messages.innerHTML = html;
      if (isConfigured) {
        elements.setupNotice.style.display = 'none';
      } else {
        elements.messages.insertAdjacentElement('afterbegin', elements.setupNotice);
      }

      // Add touch event listeners to all messages after rendering
      document.querySelectorAll('.message').forEach(msgEl => {
        const messageId = msgEl.getAttribute('data-message-id');
        
        // Use both click and touchend for better mobile support
        msgEl.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          window.selectReply(messageId);
        });
        
        msgEl.addEventListener('touchend', (e) => {
          e.preventDefault();
          e.stopPropagation();
          window.selectReply(messageId);
        }, { passive: false });
      });

      // Auto-scroll to bottom
      requestAnimationFrame(() => {
        elements.messages.scrollTop = elements.messages.scrollHeight;
      });
    }

    // Send message
    async function sendMessage() {
      const now = Date.now();

      // ðŸš¦ COOLDOWN FEEDBACK + SPAM PROTECTION
      if (now - lastSendTime < 800) {
        elements.sendBtn.disabled = true;
        elements.sendDot.classList.remove('active');

        if (cooldownTimer) clearTimeout(cooldownTimer);

        cooldownTimer = setTimeout(() => {
          elements.sendBtn.disabled = !state.isConnected || !isConfigured;

          if (elements.messageInput.value.trim().length > 0) {
            elements.sendDot.classList.add('active');
          }
        }, 800);

        return;
      }

      lastSendTime = now;

      const text = elements.messageInput.value.trim();

      if (!text || !state.isConnected || !isConfigured) return;

      try {
        const messageData = {
          text,
          userId: state.userId,
          timestamp: now,
          expiresAt: now + MESSAGE_EXPIRY_TIME,
          replyTo: replyingTo
            ? {
                text: replyingTo.text.slice(0, 80),
                timestamp: replyingTo.timestamp
              }
            : null
        };

        await push(messagesRef, messageData);

        // Clear input and reply state
        elements.messageInput.value = '';
        replyingTo = null;
        
        // Hide and reset preview
        const previewEl = document.getElementById('replyPreview');
        if (previewEl) {
          previewEl.classList.remove('visible');
          previewEl.style.display = 'none';
          previewEl.style.visibility = 'hidden';
          previewEl.style.opacity = '0';
        }
        
        // Remove highlight from selected message
        const prevSelected = document.querySelector('.selected-for-reply');
        if (prevSelected) {
          prevSelected.classList.remove('selected-for-reply');
        }
        
        elements.sendBtn.disabled = true;
        elements.sendDot.classList.remove('active');
        elements.messageInput.focus();

        console.log('âœ… Message sent' + (messageData.replyTo ? ' (with reply)' : ''));
        console.log('âœ… Preview cleared');

      } catch (error) {
        console.error('Error sending message:', error);
        elements.statusText.textContent = 'Error sending';

        setTimeout(() => {
          if (state.isConnected) {
            elements.statusText.textContent = 'Online';
          }
        }, 2000);
      }
    }

    // Initialize Firebase
    let db, messagesRef;

    if (isConfigured) {
      try {
        const app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        messagesRef = ref(db, 'messages');

        // Listen for new messages - ordered by timestamp
        const messagesQuery = query(messagesRef, orderByChild('timestamp'), limitToLast(100));
        
        onChildAdded(messagesQuery, (snapshot) => {
          const data = snapshot.val();
          const messageId = snapshot.key;

          if (!data) return;

          const now = Date.now();

          // ðŸ”¥ AUTO DELETE EXPIRED MESSAGES FROM FIREBASE
          if (data.expiresAt && data.expiresAt <= now) {
            remove(ref(db, `messages/${messageId}`));
            return;
          }

          addMessage(messageId, data);

          // Schedule future deletion
          if (data.expiresAt) {
            const timeUntilExpiry = data.expiresAt - now;

            setTimeout(() => {
              remove(ref(db, `messages/${messageId}`));
            }, timeUntilExpiry);
          }
        });

        // Listen for removed messages
        onChildRemoved(messagesQuery, (snapshot) => {
          removeMessage(snapshot.key);
        });

        updateConnectionStatus(true);
        console.log('Firebase connected successfully');
      } catch (error) {
        console.error('Firebase initialization error:', error);
        updateConnectionStatus(false);
      }
    } else {
      console.warn('Firebase not configured. Please add your Firebase config.');
      elements.setupNotice.style.display = 'block';
    }

    // Event listeners
    
    // Wrap the send button click to also clear preview
    const sendBtnClickHandler = () => {
      // Send the message
      sendMessage();
      
      // Also clear preview (in case React Native triggered this)
      setTimeout(() => {
        const previewEl = document.getElementById('replyPreview');
        if (previewEl) {
          previewEl.classList.remove('visible');
          previewEl.style.display = 'none';
          previewEl.style.visibility = 'hidden';
          previewEl.style.opacity = '0';
        }
        
        const prevSelected = document.querySelector('.selected-for-reply');
        if (prevSelected) {
          prevSelected.classList.remove('selected-for-reply');
        }
      }, 200);
    };
    
    elements.sendBtn.addEventListener('click', sendBtnClickHandler);

    // Monitor for React Native message sends (when they inject and click the button)
    const originalPush = push;
    window.detectMessageSend = function() {
      // Clear preview when message is sent via React Native
      const previewEl = document.getElementById('replyPreview');
      if (previewEl && previewEl.classList.contains('visible')) {
        console.log('ðŸ”µ Detected message send from React Native, clearing preview...');
        
        replyingTo = null;
        previewEl.classList.remove('visible');
        previewEl.style.display = 'none';
        previewEl.style.visibility = 'hidden';
        previewEl.style.opacity = '0';
        
        const prevSelected = document.querySelector('.selected-for-reply');
        if (prevSelected) {
          prevSelected.classList.remove('selected-for-reply');
        }
        
        console.log('âœ… Preview cleared after React Native send');
      }
    };

    // Watch for input changes from React Native
    let lastInputValue = '';
    setInterval(() => {
      const currentValue = elements.messageInput.value;
      // If input was filled and is now empty, a message was likely sent
      if (lastInputValue.length > 0 && currentValue.length === 0) {
        window.detectMessageSend();
      }
      lastInputValue = currentValue;
    }, 100);

    // Cancel reply button
    document.getElementById('cancelReplyBtn').addEventListener('click', () => {
      replyingTo = null;
      
      // Hide and reset preview
      const previewEl = document.getElementById('replyPreview');
      if (previewEl) {
        previewEl.classList.remove('visible');
        previewEl.style.display = 'none';
        previewEl.style.visibility = 'hidden';
        previewEl.style.opacity = '0';
      }
      
      // Remove highlight from selected message
      const prevSelected = document.querySelector('.selected-for-reply');
      if (prevSelected) {
        prevSelected.classList.remove('selected-for-reply');
      }
      
      console.log('âŒ Reply cancelled');
      console.log('âœ… Preview cleared');
    });

    elements.messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // Enable send button when input has text
    elements.messageInput.addEventListener('input', () => {
      const hasText = elements.messageInput.value.trim().length > 0;
      elements.sendBtn.disabled = !state.isConnected || !hasText || !isConfigured;
      
      // Update dot color
      if (hasText) {
        elements.sendDot.classList.add('active');
      } else {
        elements.sendDot.classList.remove('active');
      }
    });

    // Focus input on load
    if (isConfigured) {
      elements.messageInput.focus();
    }

    console.log('Chat initialized with ID:', state.userId);
  </script>
</body>
</html>
